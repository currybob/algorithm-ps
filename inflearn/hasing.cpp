// Hashing
/*
Hash table은 dynamic set을 구현하는 효과적인 방법의 하나 
	Hashing은 시간복잡도를 정확하게 계산하는데에 한계가 있으나
	(hash 값을 계산하는데에 걸리는 시간 만큼이 시간 복잡도)
	적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1)
	보통 최악의 경우 O(n)

	hash function h를 사용하여 키 k를 T[h(k)]에 저장
		h : U -> {0, 1, ...., m-1}
			여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합
		키 k가 h(k)로 해슁되었다고 함
		index = h(k) -> 즉, 각 키에 대한 해쉬함수 값을 그 키를 저장할 배열 인덱스로 사용
		예) h = k % m  

	data가 문자열이어도 가능. 어떤 데이터이든지 자연수로 해석하는 것이 가능하기 때문에

	Issue) hash함수로 계산한 값이 겹칠 수 있음 -> 두 개 이상의 키가 동일한 위치로 해슁되는 경우 (h(k1) == h(k2))
			그러면 안 겹치게 hash 함수를 만들면 되잖아? -> 일반적으로 |U| >> m 이므로 항상 발생 가능 (one-to-one function이 아님)
			대표적인 충돌 해결 방법 : chaining & open addressing
			
			1) chaining
				동일한 장소로 해슁된 모든 키들을 하나의 linked list로 저장
				- Insertion : key를 리스트 T[h(k)]의 맨 앞에 삽입 O(1)
								중복된 키가 들어올 수 있고, 만약 중복 저장이 허용되지 않는다면 삽입이 리스트를 검색해야 함.
								따라서 시간복잡도는 리스트의 길이에 비례 
				- Search : 리스트 T[h(k)]에서 순차검색. 마찬가지로 시간복잡도는 리스트의 길이에 비례
				- Deletion : 리스트 T[h(k)]로부터 키를 검색 후 삭제
								일단 키를 검색해서 찾은 후에는 O(1)시간에 삭제 가능

				최악의 경우는 모든 키가 하나의 슬롯으로 해슁되는 경우
					길이가 n인 하나의 연결리스트가 만들어짐. 따라서 최악의 경우 탐색시간은 O(n) + 해쉬함수 계산시간
				평균시간복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정

				SUHA (Simple Uniform Hashing Assumption)
					각각의 키가 모든 슬롯들에 균등한 확률로 독립적으로 해슁된다는 가정. 현실에서는 불가능
					- Load factor a = n/m  (n : 테이블에 저장될 키의 개수, m : 해쉬테이블의 크기, 즉 리스트의 개수)
							즉, 각 슬롯에 저장된 키의 평균 개수
					리스트 T[j]의 길이를 n_j라고 하면 한 슬롯에 배치될 키들의 기댓값 E[n_j] = a
					만약 n = O(m)이면 평균검색시간은 O(1)
			
			2) open addressing
				모든 키를 해쉬테이블 자체에 저장
				테이브의 각 슬롯에는 1개의 키만 저장 -> 즉, 계산된 해쉬값 말고 다른 위치에 저장
				충돌 해결 기법 : Linear probing, Quadratic probing, Double hashing
					- Linear probing
						h(k), h(k)+1, h(k)+2... 순서로 검사하여 처음으로 빈 슬롯에 저장
						테이블의 끝에 도달하면 다시 처음으로 circular하게 돌아감
						clustering이 큼 (상당수의 키들이 뭉쳐있음). 
						큰 cluster가 있을수록 삽입에 시간이 오래걸릴뿐더러 cluster가 점점 더 커짐

					- Quadratic probing
						Linear probing의 단점을 해결하기 위해 총돌 발생시 h(k), h(k)+1^2, h(k)+2^2, h(k)+3^2 ...순서로 시도

					- Double hashing
						서로 다른 두 해쉬 함수 h1과 h2를 이용하여 h(k, i) = (h1(k) + i*h2(k)) % m
						기본적인 개념은 Qudratic probing과 비슷
						이 때 두번째 해쉬함수는 값이 0이면 안 됨
						Quadratic probing과 달리 key값에 따라 offset이 달라짐

				단순히 키를 삭제할 경우 문제가 발생
				예) Linear probing으로 Insertion 했을 때, A, B, C가 같은 해쉬값을 가져서 연속으로 들어있다고 했을 때
					B를 지우면 C를 검색하는데에 문제 발생
					삭제시 원래 데이터가 있었는데 삭제된거다 라는 표시를 해주면 검색 가능. 
					그러나 dynamic set을 관리하기에 별로 좋은 생각은 아님
					따라서 삭제할 때 C나 그 뒤에 있는 data들을 앞으로 끌어와서 다시 저장 (data들이 동일한 hash값을 가지는 경우만)

	좋은 해쉬 함수란?
		현실에서는 키들이 랜덤하지 않음
		만약 키들의 통계적 분포에 대해 알고 있다면 이를 이용해서 해쉬 함수를 고안하는 것이 가능하겠지만 현실적으로 어려움
		키들이 어떤 특정한 패턴을 가지더라도 해쉬함수값이 불규칙적이 되도록 하는게 바람직 (해쉬함수값이 키의 특정 부분에 의해서만 결정x)

		- Division 기법
			h(k) = k % m
			장점 : 한번의 mod 연산으로 계산하므로 빠름
			단점 : 어떤 m값에 대해서는 해쉬 함숫값이 키값의 특정 부분에 의해서 결정되는 경우가 있음
					예를 들어 m=2^p이면 어떤 키의 하위 p비트가 해쉬 함수값이 됨
	
		- Mulitplication 기법
			0에서 1사이의 상수 A를 선택. k*A의 소수부분만을 택한다.
			소수 부분에 m을 곱한 후 소수점 아래를 버린다.
			예) m=8, wordsize=5, k=21
				A=13/32를 선택. K*A = 21*13/32 = 8 + 17/32
				m * 17/32 = 4.xxx
				즉, h(21) = 4
			key들이 특정 패턴을 가지고 있더라도 해쉬값이 랜덤으로 배정될 가능성 높음
*/
